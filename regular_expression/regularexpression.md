* 正则表达式


<https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F>

```
  \   转义

  ^  匹配输入字符串的开始位置,如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。

  $	匹配输入字符串的结束位置,如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。

  *	匹配前面的子表达式零次或多次: zo*能匹配“z”、“zo”以及“zoo”。  *等价于{0,}。

  +	匹配前面的子表达式一次或多次:
  ?	匹配前面的子表达式零次或一次
  {n}	n是一个非负整数。匹配确定的n次。
  {n,}	n是一个非负整数。至少匹配n次。
  {n,m}	m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次

  .	匹配除“\r”“\n”之外的任何单个字符。要匹配包括“\r”“\n”在内的任何字符，请使用像“(.|\r|\n)”的模式。

  (pattern)	匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到.

  (?:pattern)	匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。

  (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配。例如： "Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”

  (?!pattern) 正向否定预查（negative assert），在任何不匹配pattern的字符串开始处匹配查找字符串。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”

  (?<=pattern)	反向（look behind）肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。

  (?<!pattern)	反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。

  x|y	    没有包围在()里，其范围是整个正则表达式

  [xyz]   匹配所包含的任意一个字符

  [^xyz]  匹配未列出的任意字符

  [a-z]   例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。

  [^a-z]  例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。

  [:name:] 只能用于方括号表达式。增加命名字符类（named character class中的字符到表达式

  [=elt=]  增加当前locale下排序（collate）等价于字符“elt”的元素。例如，[=a=]可能会增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ 。只能用于方括号表达式。

  [.elt.]	增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成。例如，29个字母表的西班牙语， "CH"作为单个字母排在字母C之后，因此会产生如此排序“cinco, credo, chispa”。只能用于方括号表达式。

  \b	匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。

  \B	匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。

  \cx	匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。

  \d	匹配一个数字字符。等价于[0-9]。注意Unicode正则表达式会匹配全角数字字符。
  \D	匹配一个非数字字符。等价于[^0-9]。

  \f	匹配一个换页符。等价于\x0c和\cL。
  \n	匹配一个换行符。等价于\x0a和\cJ。
  \r	匹配一个回车符。等价于\x0d和\cM。
  \s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。注意Unicode正则表达式会匹配全角空格符。
  \S	匹配任何非空白字符。等价于[^ \f\n\r\t\v]。
  \t	匹配一个制表符。等价于\x09和\cI。
  \v	匹配一个垂直制表符。等价于\x0b和\cK。
  \w	匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。注意Unicode正则表达式会匹配中文字符。
  \W	匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
  \ck	匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法。




  正则表达式[\w]+,\w+,[\w+] 三者有何区别：
  [\w]+和\w+没有区别，都是匹配数字和字母下划线的多个字符；
  [\w+]表示匹配数字、字母、下划线和加号本身字符；
```
预查：
```
var s = "abc"
console.log(/a(?=b)bc/.test(s))
console.log(/a(b)bc/.test(s))

true
false

/a(?=b)bc/中的正向肯定预查(?=b)匹配了a后面的字母b，但是并没有消耗它，所以，后面再跟一个“bc”串，这就完整地匹配了字符串“abc”。其实，它的真正意义应该是确定了这个字母a，因为不是每个字母a后面都会跟一个字母b的！
而a(b)bc因为匹配并消耗了字母a后面的b，再来添加一个“bc”串的时候，就变成了“abbc”，就不能匹配字符串“abc”。

```
